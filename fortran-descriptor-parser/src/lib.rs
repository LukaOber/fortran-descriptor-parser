//! # fortran_descriptor_parser
//!
//! `fortran_descriptor_parser` provides a macro [`descriptor_parser`] to generate a parser at compile time
//! to parse bytes which are formatted according to a [fortran format edit descriptor][ObliquityFormat]. The macro uses
//! a simplified syntax inspired by the format used in the fortran descriptors.
//!
//! ### Syntax
//! `nTw`\
//! `n` = number of repetitions\
//! `T` = the type to parse (I: i32, S: String, F: f32, D: f64)\
//! `w` = number of bytes to take
//!
//! ### Basic example
//! ```rust
//! use fortran_descriptor_parser::descriptor_parser;
//!
//! let input = " -0.31415D+01";
//! let f = descriptor_parser!("D13")(input.as_bytes()).unwrap();
//! assert_eq!(f, -3.1415);
//! ```
//!
//! ### Explained example
//! ```rust
//! use fortran_descriptor_parser::descriptor_parser;
//!
//! // input is a string generated by a fortran program.
//! // For this example a format edit descriptor like the following has been used:
//! // FORMAT(I10, A10, E13.5, D13.5) and values 1, "Test", -3.1415, 3.1415
//! let input = "         1      Test -0.31415E+01  0.31415D+01";
//!
//! // The descriptor_parser macro generates four parsers in a tuple
//! // bytes 0..10 get parsed into an i32
//! // bytes 10..20 get parsed into a String
//! // bytes 20..33 get parsed into a f32
//! // bytes 33..46 get parsed into a f64
//! let (i, s, f, d) = descriptor_parser!("I10,S10,F13,D13")(input.as_bytes()).unwrap();
//! assert_eq!(i, 1);
//! assert_eq!(s, "Test");
//! assert_eq!(f, -3.1415);
//! assert_eq!(d, 3.1415);
//! ```
//!
//! ### Repetitions
//! ```rust
//! use fortran_descriptor_parser::descriptor_parser;
//!
//! // repetition of single elements can be done like this
//! descriptor_parser!("3I10");
//! // which is equivalent to
//! descriptor_parser!("I10,I10,I10");
//!
//! // repetition of multiple elements is also supported
//! descriptor_parser!("2(I5,S5)");
//! // which is equivalent to
//! descriptor_parser!("I5,S5,I5,S5");
//! ```
//!
//! The macro can parse `i32`, `f32`, `f64` and `Strings`
//!
//! [ObliquityFormat]: https://www.obliquity.com/computer/fortran/format.html

pub use fortran_descriptor_parser_macro::descriptor_parser;
use lexical::{format::STANDARD, parse, parse_with_options};
use thiserror::Error;

/// Errors which can be generated by the [`descriptor_parser`]
#[derive(Error, Debug)]
pub enum DescriptorParserError {
    #[error("Can't convert '{0}' into f32")]
    Invalidf32(String),
    #[error("Can't convert '{0}' into f64")]
    Invalidf64(String),
    #[error("Can't convert '{0}' into i32")]
    Invalidi32(String),
    #[error("Found {0} bytes, expected at least {1}")]
    NotEnoughBytes(usize, usize),
}

/// Trait which allows converting a byte slice to an inferred type.
/// The trait gets used in the macro but can also be used on its own.
/// ```rust
/// use fortran_descriptor_parser::FromSlice;
///
/// let input = "3.1416".as_bytes();
/// let f: f32 = input.to_type().unwrap();
/// assert_eq!(3.1416, f);
/// ```
pub trait FromSlice<T> {
    fn to_type(&self) -> Result<T, DescriptorParserError>;
}

impl FromSlice<f32> for [u8] {
    fn to_type(&self) -> Result<f32, DescriptorParserError> {
        let f_res = parse(self.trim_ascii()).map_err(|_| {
            DescriptorParserError::Invalidf32(String::from_utf8_lossy(self).to_string())
        });
        match f_res {
            Ok(_) => f_res,
            Err(_) => {
                let options = lexical::ParseFloatOptions::builder()
                    .exponent(b'D')
                    .build()
                    .unwrap();
                parse_with_options::<f32, _, STANDARD>(self.trim_ascii(), &options).map_err(|_| {
                    DescriptorParserError::Invalidf32(String::from_utf8_lossy(self).to_string())
                })
            }
        }
    }
}

impl FromSlice<f64> for [u8] {
    fn to_type(&self) -> Result<f64, DescriptorParserError> {
        let options = lexical::ParseFloatOptions::builder()
            .exponent(b'D')
            .build()
            .unwrap();
        let f_res =
            parse_with_options::<f64, _, STANDARD>(self.trim_ascii(), &options).map_err(|_| {
                DescriptorParserError::Invalidf64(String::from_utf8_lossy(self).to_string())
            });
        match f_res {
            Ok(_) => f_res,
            Err(_) => parse(self.trim_ascii()).map_err(|_| {
                DescriptorParserError::Invalidf64(String::from_utf8_lossy(self).to_string())
            }),
        }
    }
}

impl FromSlice<i32> for [u8] {
    fn to_type(&self) -> Result<i32, DescriptorParserError> {
        parse(self.trim_ascii()).map_err(|_| {
            DescriptorParserError::Invalidi32(String::from_utf8_lossy(self).to_string())
        })
    }
}

impl FromSlice<String> for [u8] {
    fn to_type(&self) -> Result<String, DescriptorParserError> {
        Ok(String::from_utf8_lossy(self.trim_ascii()).to_string())
    }
}

#[doc(hidden)]
pub fn get_sub_slice<'a>(start_byte: &mut usize, width: usize, slice: &'a [u8]) -> &'a [u8] {
    let end_byte = *start_byte + width;
    let s = &slice[*start_byte..end_byte];
    *start_byte += width;
    s
}
